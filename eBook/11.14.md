# 結構體、集合和高階函數

通常你在應用中定義了一個結構體，那麼你也可能需要這個結構體的（指針）對象集合，比如：

```go
type Any interface{}
type Car struct {
	Model        string
	Manufacturer string
	BuildYear    int
	// ...
}

type Cars []*Car
```

在定義所需功能時我們可以利用函數可以作爲（其它函數的）參數的事實來使用高階函數，例如：

1）定義一個通用的 `Process()` 函數，它接收一個作用於每一輛 car 的 f 函數作參數：

```go
// Process all cars with the given function f:
func (cs Cars) Process(f func(car *Car)) {
	for _, c := range cs {
		f(c)
	}
}
```

2）在上面的基礎上，實現一個查找函數來獲取子集合，並在 `Process()` 中傳入一個閉包執行（這樣就可以訪問局部切片 `cars`）：

```go
// Find all cars matching a given criteria.
func (cs Cars) FindAll(f func(car *Car) bool) Cars {

	cars := make([]*Car, 0)
	cs.Process(func(c *Car) {
			if f(c) {
                append(cars,c)
            }
    )
	return cars
}
```

3）實現 Map 功能，產出除 car 對象以外的東西：

```go
// Process cars and create new data.
func (cs Cars) Map(f func(car *Car) Any) []Any {
		result := make([]Any, 0)
		ix := 0
		cs.Process(func(c *Car) {
				result[ix] = f(c)
				ix++
		})
       	return result
}
```

現在我們可以定義下面這樣的具體查詢：

```go
allNewBMWs := allCars.FindAll(func(car *Car) bool {
       return (car.Manufacturer == “BMW”) && (car.BuildYear > 2010)
})
```

4）我們也可以根據入參返回不同的函數。也許我們想根據不同的廠商添加汽車到不同的集合，但是這可能會是多變的。所以我們可以定義一個函數來產生特定的添加函數和 map 集：

```go
func MakeSortedAppender(manufacturers[]string)(func(car*Car),map[string]Cars) {
	// Prepare maps of sorted cars.
	sortedCars := make(map[string]Cars)
	for _, m := range manufacturers {
		sortedCars[m] = make([]*Car, 0)
	}
	sortedCars[“Default”] = make([]*Car, 0)
	// Prepare appender function:
	appender := func(c *Car) {
		if _, ok := sortedCars[c.Manufacturer]; ok {
			sortedCars[c.Manufacturer] = append(sortedCars[c.Manufacturer], c)
		} else {
			sortedCars[“Default”] = append(sortedCars[“Default”], c)
		}

 	}
	return appender, sortedCars
}
```

現在我們可以用它把汽車分類爲獨立的集合，像這樣：

```go
manufacturers := []string{“Ford”, “Aston Martin”, “Land Rover”, “BMW”, “Jaguar”}
sortedAppender, sortedCars := MakeSortedAppender(manufacturers)
allUnsortedCars.Process(sortedAppender)
BMWCount := len(sortedCars[“BMW”])
```

我們讓這些代碼在下面的程序 cars.go（此處只展示了 main() 中的代碼，別的代碼已經在上面展示）中執行：

示例 11.18 [cars.go](examples/chapter_11/cars.go)：

```go
// cars.go
package main

import (
	"fmt"
)

type Any interface{}
type Car struct {
	Model   	string
	Manufacturer	string
	BuildYear	int
    // ...
}
type Cars []*Car

func main() {
	// make some cars:
	ford := &Car{"Fiesta","Ford", 2008}
	bmw  := &Car{"XL 450", "BMW", 2011}
	merc := &Car{"D600", "Mercedes", 2009}
	bmw2 := &Car{"X 800", "BMW", 2008}
	// query:
	allCars := Cars([]*Car{ford, bmw, merc, bmw2})
	allNewBMWs := allCars.FindAll(func(car *Car) bool {
      return (car.Manufacturer == "BMW") && (car.BuildYear > 2010)
	})
	fmt.Println("AllCars: ", allCars)
	fmt.Println("New BMWs: ", allNewBMWs)
	//
	manufacturers := []string{"Ford", "Aston Martin", "Land Rover", "BMW", "Jaguar"}
	sortedAppender, sortedCars := MakeSortedAppender(manufacturers)
	allCars.Process(sortedAppender)
	fmt.Println("Map sortedCars: ", sortedCars)
    BMWCount := len(sortedCars["BMW"])
	fmt.Println("We have ", BMWCount, " BMWs")
}

// Process all cars with the given function f:
func (cs Cars) Process(f func(car *Car)) {
     for _, c := range cs {
         f(c)
     }
}

// Find all cars matching a given criteria.
func (cs Cars) FindAll(f func(car *Car) bool) Cars {
    cars := make([]*Car, 0)

    cs.Process(func(c *Car) {
        if f(c) {
            cars = append(cars, c)
        }
    })
    return cars
}

// Process cars and create new data.
func (cs Cars) Map(f func(car *Car) Any) []Any {
       result := make([]Any, 0)
       ix := 0
       cs.Process(func(c *Car) {
           result[ix] = f(c)
           ix++
       })
       return result
}

func MakeSortedAppender(manufacturers []string) (func(car *Car), map[string]Cars) {
     // Prepare maps of sorted cars.
       sortedCars := make(map[string]Cars)

       for _, m := range manufacturers {
           sortedCars[m] = make([]*Car, 0)
       }
       sortedCars["Default"] = make([]*Car, 0)

       // Prepare appender function:
       appender := func(c *Car) {
           if _, ok := sortedCars[c.Manufacturer]; ok {
               sortedCars[c.Manufacturer] = append(sortedCars[c.Manufacturer], c)
           } else {
               sortedCars["Default"] = append(sortedCars["Default"], c)
           }
       }
       return appender, sortedCars
}
```

輸出：

```
AllCars:  [0xf8400038a0 0xf840003bd0 0xf840003ba0 0xf840003b70]
New BMWs:  [0xf840003bd0]
Map sortedCars:  map[Default:[0xf840003ba0] Jaguar:[] Land Rover:[] BMW:[0xf840003bd0 0xf840003b70] Aston Martin:[] Ford:[0xf8400038a0]]
We have  2  BMWs
```


## 鏈接

- [目錄](directory.md)
- 上一節：[Go 中的面向對象](11.13.md)
- 下一章：[讀寫數據](12.0.md)
