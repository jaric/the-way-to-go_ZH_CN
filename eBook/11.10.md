# 11.10 反射包

## 11.10.1 方法和類型的反射

在 10.4 節我們看到可以通過反射來分析一個結構體。本節我們進一步探討強大的反射功能。反射是用程序檢查其所擁有的結構，尤其是類型的一種能力；這是元編程的一種形式。反射可以在運行時檢查類型和變量，例如它的大小、方法和 `動態`
的調用這些方法。這對於沒有源代碼的包尤其有用。這是一個強大的工具，除非真得有必要，否則應當避免使用或小心使用。

變量的最基本信息就是類型和值：反射包的 `Type` 用來表示一個 Go 類型，反射包的 `Value` 爲 Go 值提供了反射接口。

兩個簡單的函數，`reflect.TypeOf` 和 `reflect.ValueOf`，返回被檢查對象的類型和值。例如，x 被定義爲：`var x float64 = 3.4`，那麼 `reflect.TypeOf(x)` 返回 `float64`，`reflect.ValueOf(x)` 返回 `<float64 Value>`

實際上，反射是通過檢查一個接口的值，變量首先被轉換成空接口。這從下面兩個函數簽名能夠很明顯的看出來：

```go
func TypeOf(i interface{}) Type
func ValueOf(i interface{}) Value
```

接口的值包含一個 type 和 value。

反射可以從接口值反射到對象，也可以從對象反射回接口值。

reflect.Type 和 reflect.Value 都有許多方法用於檢查和操作它們。一個重要的例子是 Value 有一個 Type 方法返回 reflect.Value 的 Type。另一個是 Type 和 Value 都有 Kind 方法返回一個常量來表示類型：Uint、Float64、Slice 等等。同樣 Value 有叫做 Int 和 Float 的方法可以獲取存儲在內部的值（跟 int64 和 float64 一樣）

```go
const (
	Invalid Kind = iota
	Bool
	Int
	Int8
	Int16
	Int32
	Int64
	Uint
	Uint8
	Uint16
	Uint32
	Uint64
	Uintptr
	Float32
	Float64
	Complex64
	Complex128
	Array
	Chan
	Func
	Interface
	Map
	Ptr
	Slice
	String
	Struct
	UnsafePointer
)
```

對於變量 x，如果 `v:=reflect.ValueOf(x)`，那麼 `v.Kind()` 返回 float64 ，所以下面的表達式是 `true`
`v.Kind() == reflect.Float64`

Kind 總是返回底層類型：

```go
type MyInt int
var m MyInt = 5
v := reflect.ValueOf(m)
```

方法 `v.Kind()` 返回 `reflect.Int`。

變量 v 的 `Interface()` 方法可以得到還原（接口）值，所以可以這樣打印 v 的值：`fmt.Println(v.Interface())`


嘗試運行下面的代碼：

示例 11.11 [reflect1.go](examples/chapter_11/reflect1.go)：

```go
// blog: Laws of Reflection
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var x float64 = 3.4
	fmt.Println("type:", reflect.TypeOf(x))
	v := reflect.ValueOf(x)
	fmt.Println("value:", v)
	fmt.Println("type:", v.Type())
	fmt.Println("kind:", v.Kind())
	fmt.Println("value:", v.Float())
	fmt.Println(v.Interface())
	fmt.Printf("value is %5.2e\n", v.Interface())
	y := v.Interface().(float64)
	fmt.Println(y)
}
```

輸出：

```
type: float64
value: 3.4
type: float64
kind: float64
value: 3.4
3.4
value is 3.40e+00
3.4
```

x 是一個 float64 類型的值，`reflect.ValueOf(x).Float()` 返回這個 float64 類型的實際值；同樣的適用於 `Int(), Bool(), Complex(), String()`

## 11.10.2 通過反射修改(設置)值

繼續前面的例子（參閱 11.9 [reflect2.go](examples/chapter_11/reflect2.go)），假設我們要把 x 的值改爲 3.1415。Value 有一些方法可以完成這個任務，但是必須小心使用：`v.SetFloat(3.1415)`。

這將產生一個錯誤：`reflect.Value.SetFloat using unaddressable value`。

爲什麼會這樣呢？問題的原因是 v 不是可設置的（這裏並不是說值不可尋址）。是否可設置是 Value 的一個屬性，並且不是所有的反設值都有這個屬性：可以使用 `CanSet()` 方法測試是否可設置。

在例子中我們看到 `v.CanSet()` 返回 false： `settability of v: false`

當 `v := reflect.ValueOf(x)` 函數通過傳遞一個 x 拷貝創建了 v，那麼 v 的改變並不能更改原始的 x。要想 v 的更改能作用到 x，那就必須傳遞 x 的地址 `v = reflect.ValueOf(&x)`。

通過 Type() 我們看到 v 現在的類型是 `*float64` 並且仍然是不可設置的。

要想讓其可設置我們需要使用 `Elem()` 函數，這間接的使用指針：`v = v.Elem()`

現在 `v.CanSet()` 返回 true 並且 `v.SetFloat(3.1415)` 設置成功了！


示例 11.12 [reflect2.go](examples/chapter_11/reflect2.go)：

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var x float64 = 3.4
	v := reflect.ValueOf(x)
	// setting a value:
	// v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value
	fmt.Println("settability of v:", v.CanSet())
	v = reflect.ValueOf(&x) // Note: take the address of x.
	fmt.Println("type of v:", v.Type())
	fmt.Println("settability of v:", v.CanSet())
	v = v.Elem()
	fmt.Println("The Elem of v is: ", v)
	fmt.Println("settability of v:", v.CanSet())
	v.SetFloat(3.1415) // this works!
	fmt.Println(v.Interface())
	fmt.Println(v)
}
```

輸出：

```
settability of v: false
type of v: *float64
settability of v: false
The Elem of v is:  <float64 Value>
settability of v: true
3.1415
<float64 Value>
```

反射中有些內容是需要用地址去改變它的狀態的。

## 11.10.3 反射結構

有些時候需要反射一個結構類型。`NumField()` 方法返回結構內的字段數量；通過一個 for 循環用索引取得每個字段的值 `Field(i)`。

我們同樣能夠調用簽名在結構上的方法，例如，使用索引 n 來調用：`Method(n).Call(nil)`。

示例 11.13 [reflect_struct.go](examples/chapter_11/reflect_struct.go)：

```go
package main

import (
	"fmt"
	"reflect"
)

type NotknownType struct {
	s1, s2, s3 string
}

func (n NotknownType) String() string {
	return n.s1 + " - " + n.s2 + " - " + n.s3
}

// variable to investigate:
var secret interface{} = NotknownType{"Ada", "Go", "Oberon"}

func main() {
	value := reflect.ValueOf(secret) // <main.NotknownType Value>
	typ := reflect.TypeOf(secret)    // main.NotknownType
	// alternative:
	//typ := value.Type()  // main.NotknownType
	fmt.Println(typ)
	knd := value.Kind() // struct
	fmt.Println(knd)

	// iterate through the fields of the struct:
	for i := 0; i < value.NumField(); i++ {
		fmt.Printf("Field %d: %v\n", i, value.Field(i))
		// error: panic: reflect.Value.SetString using value obtained using unexported field
		//value.Field(i).SetString("C#")
	}

	// call the first method, which is String():
	results := value.Method(0).Call(nil)
	fmt.Println(results) // [Ada - Go - Oberon]
}
```

輸出：

```
main.NotknownType
struct
Field 0: Ada
Field 1: Go
Field 2: Oberon
[Ada - Go - Oberon]
```

但是如果嘗試更改一個值，會得到一個錯誤：

```
panic: reflect.Value.SetString using value obtained using unexported field
```

這是因爲結構中只有被導出字段（首字母大寫）纔是可設置的；來看下面的例子：

示例 11.14 [reflect_struct2.go](examples/chapter_11/reflect_struct2.go)：

```go
package main

import (
	"fmt"
	"reflect"
)

type T struct {
	A int
	B string
}

func main() {
	t := T{23, "skidoo"}
	s := reflect.ValueOf(&t).Elem()
	typeOfT := s.Type()
	for i := 0; i < s.NumField(); i++ {
		f := s.Field(i)
		fmt.Printf("%d: %s %s = %v\n", i,
			typeOfT.Field(i).Name, f.Type(), f.Interface())
	}
	s.Field(0).SetInt(77)
	s.Field(1).SetString("Sunset Strip")
	fmt.Println("t is now", t)
}
```

輸出：

```
0: A int = 23
1: B string = skidoo
t is now {77 Sunset Strip}
```

附錄 37 深入闡述了反射概念。

## 鏈接

- [目錄](directory.md)
- 上一節：[空接口](11.9.md)
- 下一節：[Printf 和反射](11.11.md)
