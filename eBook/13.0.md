# 13 錯誤處理與測試

Go 沒有像 Java 和 .NET 那樣的 `try/catch` 異常機制：不能執行拋異常操作。但是有一套 `defer-panic-and-recover` 機制（參見 13.2-13.3 節）。

Go 的設計者覺得 `try/catch` 機制的使用太氾濫了，而且從底層向更高的層級拋異常太耗費資源。他們給 Go 設計的機制也可以 “捕捉” 異常，但是更輕量，並且只應該作爲（處理錯誤的）最後的手段。

Go 是怎麼處理普通錯誤的呢？通過在函數和方法中返回錯誤對象作爲它們的唯一或最後一個返回值——如果返回 nil，則沒有錯誤發生——並且主調（calling）函數總是應該檢查收到的錯誤。

**永遠不要忽略錯誤，否則可能會導致程序崩潰！！**

處理錯誤並且在函數發生錯誤的地方給用戶返回錯誤信息：照這樣處理就算真的出了問題，你的程序也能繼續運行並且通知給用戶。`panic and recover` 是用來處理真正的異常（無法預測的錯誤）而不是普通的錯誤。

庫函數通常必須返回某種錯誤提示給主調（calling）函數。

在前面的章節中我們瞭解了 Go 檢查和報告錯誤條件的慣有方式：

- 產生錯誤的函數會返回兩個變量，一個值和一個錯誤碼；如果後者是 nil 就是成功，非 nil 就是發生了錯誤。

- 爲了防止發生錯誤時正在執行的函數（如果有必要的話甚至會是整個程序）被中止，在調用函數後必須檢查錯誤。

下面這段來自 pack1 包的代碼 Func1 測試了它的返回值：

```go
if value, err := pack1.Func1(param1); err != nil {
	fmt.Printf(“Error %s in pack1.Func1 with parameter %v”, err.Error(), param1)
	return    // or: return err
}
// Process(value)
```

*爲了更清晰的代碼，應該總是使用包含錯誤值變量的 if 複合語句*

上例除了 `fmt.Printf` 還可以使用 log 中對應的方法（參見 13.3 節 和 15.2 節），如果程序中止也沒關係的話甚至可以使用 `panic`（參見後面的章節）。

## 鏈接

- [目錄](directory.md)
- 上一節：[Go 中的密碼學](12.12.md)
- 下一節：[錯誤處理](13.1.md)
